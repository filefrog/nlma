#!/usr/bin/perl

use strict;

use Getopt::Long;
use POSIX;
my $opts = {};
my $pid;
my $ALARMED = 0;
my $TERMED  = 0;

GetOptions($opts, 'timeout|t=i', 'debug|D', 'name|n=s');
unless ($opts->{timeout}) {
	print "No timeout defined. Cannot continue.\n";
	usage();
}

unless ($opts->{name}) {
	print "No name defined. Cannot continue.\n";
	usage();
}

my @cmd_args = @ARGV;

unless (@cmd_args) {
	print "No command provided. Cannot continue.\n";
	usage();
}

local $SIG{ALRM} = sub {
	$ALARMED = 1;
};

alarm $opts->{timeout};

$pid = fork;
if ($pid) {
	DEBUG("Forked child on $pid. Parent is $$");
	while (! waitpid($pid, POSIX::WNOHANG)) {
		if ($TERMED) {
			print STDERR "check $opts->{name} pid $pid exceeded hard_stop; sending SIGKILL\n";
			kill(KILL => $pid);
			waitpid($pid, POSIX::WNOHANG);
			last;
		} elsif ($ALARMED) {
			print STDERR "check $opts->{name} pid $pid exceeded soft_stop; sending SIGTERM\n";
			kill(TERM => $pid);
			$TERMED = 1;
		}

		sleep 1;
	}
	my $rc = WIFEXITED($?) ? WEXITSTATUS($?) : 3;
	print "check timed out (exceeded NLMA timeout)\n" if $ALARMED;
	exit $rc;
} elsif ($pid == 0) {
	DEBUG("Child process executing '".join(" ", @cmd_args)."' under $opts->{timeout} second timeout.");
	my $cmd = shift @cmd_args;
	exec $cmd, @cmd_args;
}

sub DEBUG
{
	foreach (@_) {
		chomp $_;
		print STDERR $_ . "\n" if $opts->{debug};
	}
}

sub usage
{
	print "Usage:\t$0 -t|--timeout <seconds> -n|--name <service_name> [-D|--debug] -- <check_command>\n";
	print "\t\t-t|--timeout     Specify the number of seconds the check can run before timing it out.\n";
	print "\t\t-n|--name        Specify the service name that this check is running for (to provide useful messaging if kill signalsare sent)\n";
	print "\t\t-D|--debug       Enable debugging.\n";
	print "\t\t<check_cmd>      Specify the exact check command to run (with full path) inside the timeout wrapper\n";
	exit 3;
}


